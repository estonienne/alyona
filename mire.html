<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Creature. Maker. Mire. – Alyona Movko-Mägi</title>
  <style>
    body {
      --bg-color: #fff;
      --text-color: #111;
      font-family: monospace;
      background-color: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 2rem;
      transition: background-color 0.5s ease, color 0.5s ease;
    }
    h1 {
      font-size: 24px;
      margin-bottom: 1rem;
    }
    .meta {
      font-size: 14px;
      margin-bottom: 1rem;
    }
    .materials {
      font-style: italic;
    }
    .location {
      font-size: 12px;
      text-align: right;
      margin-bottom: 1.5rem;
    }
    .description {
      margin: 2rem 0;
      white-space: pre-wrap;
      line-height: 1.6;
    }
    .gallery img {
  display: block;
  margin: 20px auto;
  opacity: 0;
  transition: opacity 1s ease;
      width: 100%;
      max-width: 700px;
      margin-top: 20px;
      cursor: pointer;
      transition: opacity 0.5s ease;
    }
    .caption {
      font-size: 12px;
      opacity: 0.6;
      margin-top: 0.4rem;
    }
    .fullscreen-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    .fullscreen-overlay img {
      max-width: 90vw;
      max-height: 80vh;
    }
    .fullscreen-caption {
      color: white;
      font-size: 7px;
      margin-top: 1rem;
      max-width: 90vw;
      text-align: center;
    }
    .fullscreen-controls {
      position: absolute;
      bottom: 20px;
      display: flex;
      gap: 20px;
    }
    .fullscreen-btn {
      background: rgba(255,255,255,0.2);
      color: white;
      border: none;
      padding: 8px 16px;
      cursor: pointer;
      font-family: monospace;
      transition: background 0.3s;
    }
    .fullscreen-btn:hover {
      background: rgba(255,255,255,0.3);
    }
  
    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      pointer-events: none;
    }
    main {
      position: relative;
      z-index: 1;
    }
    
    .nav-links {
      margin-top: 4rem;
      font-size: 13px;
      display: flex;
      justify-content: space-between;
    }
    main {
      animation: fadeIn 1.2s ease;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .controls {
      position: fixed;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 10px;
      z-index: 1001;
    }
    
    .dark-toggle, .shuffle-btn {
      font-family: monospace;
      background: none;
      border: 1px solid currentColor;
      padding: 4px 10px;
      font-size: 13px;
      color: inherit;
      cursor: pointer;
      transition: background 0.3s, color 0.3s;
    }
    
    body.dark {
      --bg-color: #111;
      --text-color: #eee;
    }
  </style>
</head>
<body>
<div class="controls">
  <button class="dark-toggle" onclick="toggleDark()">dark / light</button>
</div>
<canvas id="asciiCanvas"></canvas>
  <main id="content">
    <h1>Creature. Maker. Mire.</h1>
    <div class="meta">2025 <span class="materials">Leather, glass, bone, wood, light, photography, parchment, rust, photopolymer resin, carbon fiber–reinforced PLA.</span></div>
    <div class="location">Museum of Photography, Seek gallery</div>
    <div class="description">
<b>Creature. Maker. Mire. / Olend. Looja. Soo.</b>  is a conceptual and material research project that explores the bog as a space of layered time, transformation, and embedded memory. The work unfolds through tactile and time-based media—leather, glass, bone, wood, light, photography, and digitally fabricated forms—and engages with questions of how matter preserves, responds, and reshapes in relation to loss, care, and embodied presence. I approach the bog as a slow-thinking body: a material presence that absorbs, presses, reshapes, and holds.

Drawing from Estonian regilaul, environmental mythologies, and traditional material knowledge, the project investigates the bog as both landscape and metaphor—where things are not only buried, but transformed and re-emerge in altered form. The bog is at once an archive and an alchemist.

The conceptual frame emerged through my personal experience of moving from the city to a farmhouse in Lahemaa, surrounded by forest and wetland. Initially seen as a space to cultivate and inhabit, the land resisted that logic. It became clear that this was not a blank canvas, but a living entity with its own rhythms, histories, and resistances. That encounter shifted the project’s orientation—from shaping a landscape to listening to it. Materials found and formed through this process—fallen trees, bones, rusted metal, forgotten thresholds—became collaborators.

The bog’s temporality—its slowness, saturation, and sedimentation—serves as a model for both method and form. Rather than composing works from an external concept, I followed what the materials revealed: what softened, what resisted, what settled. Leather remembers touch. Wood remembers structure. Glass freezes gravity and heat. Bone and rust remember time. Photography registers presence through light and surface, capturing not what is seen, but what remains. Digitally fabricated forms, some derived from archival traces and others from moss-covered textile structures overtaken by nature, extend this vocabulary into volumetric materia.

The project also reflects on the ethics of presence and disappearance. The bog, as a site, has often served in folklore as a place of loss—where children vanish, where offerings sink, where the known becomes untraceable. But in that loss, something else emerges: not the original, but the echo, the imprint, the hollow where something once was. This principle of partial return—of form without function, of body without narrative—runs throughout the work.

Central to the process is the question of care: what does it mean to care for land, for memory, for material? And how do these forms of care avoid slipping into domination or nostalgia? Through time-based processes—soaking, molding, burning, burying, exposing—I approached materials as responsive bodies. Each gesture of intervention was also an act of attention. In some cases, care meant stepping back. In others, it meant stepping in.

I see my master’s thesis project as a practice of material conversation, of felt response, of co-presence with what persists and what recedes. It embraces the incomplete, the slow, the shifting. Like the bog, it does not offer clarity or resolution—but holds the weight of time, the softness of decay, and the pressure of what is no longer fully here, but not yet gone.
   <div class="gallery" id="imageGallery">
  <!-- Images 1–25 -->
  <script>
    const gallery = document.getElementById('imageGallery');
    const fullscreenImages = [];
    for (let i = 1; i <= 25; i++) {
      const imgSrc = `images/mire/mire${i}.jpg`;
      const caption = (i === 25) ? 'Photo: Hedi Jaansoo' : '';
      const container = document.createElement('div');
      const img = document.createElement('img');
      const cap = document.createElement('div');

      img.src = imgSrc;
      img.onclick = () => showFullscreen(i - 1);
      cap.className = 'caption';
      cap.textContent = caption;

      container.appendChild(img);
      container.appendChild(cap);
      gallery.appendChild(container);

      fullscreenImages.push({ src: imgSrc, caption });
    }
  </script>
</div>

    
</main>

  <script>
    let currentIndex = 0;

function showFullscreen(index) {
  currentIndex = index;
  const image = fullscreenImages[currentIndex];
  const overlay = document.createElement("div");
  overlay.className = "fullscreen-overlay";
  overlay.tabIndex = 0;

  overlay.innerHTML = `
    <img src="${image.src}" alt="">
    <div class="fullscreen-caption">${image.caption}</div>
  `;

  overlay.addEventListener("click", () => overlay.remove());

  overlay.addEventListener("keydown", (e) => {
    if (e.key === "ArrowRight") navigateFullscreen(1);
    else if (e.key === "ArrowLeft") navigateFullscreen(-1);
    else if (e.key === "Escape") overlay.remove();
  });

  document.body.appendChild(overlay);
  overlay.focus();
}

function navigateFullscreen(direction) {
  currentIndex = (currentIndex + direction + fullscreenImages.length) % fullscreenImages.length;
  const overlay = document.querySelector('.fullscreen-overlay');
  const img = overlay.querySelector("img");
  const cap = overlay.querySelector(".fullscreen-caption");

  img.src = fullscreenImages[currentIndex].src;
  cap.textContent = fullscreenImages[currentIndex].caption;
}

      
      // Create the content with controls
      overlay.innerHTML = `
        <img src="${image.src}" alt="">
        <div class="fullscreen-caption">${image.caption}</div>
        
      `;
      
      // Set up button events
      
      
      
      
      // Close on overlay click
      overlay.addEventListener("click", () => overlay.remove());
      
      // Add keyboard navigation
      overlay.addEventListener("keydown", (e) => {
        if (e.key === "ArrowRight") {
          navigateFullscreen(1);
        } else if (e.key === "ArrowLeft") {
          navigateFullscreen(-1);
        } else if (e.key === "Escape") {
          overlay.remove();
        }
      });
      
      document.body.appendChild(overlay);
      overlay.focus();
    
    
    function navigateFullscreen(direction) {
      currentIndex = (currentIndex + direction + fullscreenImages.length) % fullscreenImages.length;
      const overlay = document.querySelector('.fullscreen-overlay');
      const img = overlay.querySelector("img");
      const cap = overlay.querySelector(".fullscreen-caption");
      
      img.src = fullscreenImages[currentIndex].src;
      cap.innerHTML = fullscreenImages[currentIndex].caption;
    }
  
    function toggleDark() {
      document.body.classList.toggle('dark');
    }
  </script>

<script>
const canvas = document.getElementById("asciiCanvas");
const ctx = canvas.getContext("2d");
let width, height, mouseX = 0.5;
const roots = [], letters = "abcdefghijklmnopqrstuvwxyz".split("");
const maxRoots = 150;

function setupCanvas() {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
  roots.length = 0;
  for (let i = 0; i < 50; i++) roots.push(createBranch());
}

function createBranch(x = Math.random() * width, y = height + Math.random() * 100) {
  return {
    x, y,
    speed: 0.5 + Math.random(),
    angle: Math.PI * 1.5 + (Math.random() - 0.5),
    lifetime: 0,
    opacity: 1,
    faded: false,
    fadeCounter: 200,
    path: []
  };
}

function drawCanvas() {
  // Draw a semi-transparent rect to create trailing effect
  if (document.body.classList.contains('dark')) {
    ctx.fillStyle = "rgba(17,17,17,0.06)";
  } else {
    ctx.fillStyle = "rgba(255,255,255,0.06)";
  }
  ctx.fillRect(0, 0, width, height);
  ctx.font = "12px monospace";

  for (let b of roots) {
    const wind = (mouseX - 0.5) * 0.4;
    b.angle += wind * 0.05;
    b.x += Math.cos(b.angle) * b.speed;
    b.y += -Math.abs(Math.sin(b.angle)) * b.speed;
    b.lifetime++;
    b.path.push({ x: b.x, y: b.y });

    if (b.y < height * 0.25 && !b.faded) b.faded = true;
    if (b.faded) b.opacity -= 1 / b.fadeCounter;
    if (b.opacity <= 0 || b.y < -20 || b.path.length > 700) Object.assign(b, createBranch());

    if (Math.random() < 0.25) {
      // Adjust color based on dark mode
      if (document.body.classList.contains('dark')) {
        ctx.fillStyle = `rgba(220,220,220,${Math.max(0, b.opacity)})`;
      } else {
        ctx.fillStyle = `rgba(120,120,120,${Math.max(0, b.opacity)})`;
      }
      ctx.fillText(letters[Math.floor(Math.random() * letters.length)], b.x, b.y);
    }

    if (Math.random() < 0.01 && b.lifetime < 100 && roots.length < maxRoots) {
      const newAngle = b.angle + (Math.random() - 0.5);
      roots.push({ ...b, angle: newAngle, path: [...b.path] });
    }
  }
}

setupCanvas();
setInterval(drawCanvas, 50);
window.addEventListener("resize", setupCanvas);
window.addEventListener("mousemove", e => { mouseX = e.clientX / window.innerWidth });
window.addEventListener("click", e => {
  const rect = canvas.getBoundingClientRect();
  roots.push(createBranch(e.clientX - rect.left, e.clientY - rect.top));
});
</script>


<script>
window.addEventListener("DOMContentLoaded", () => {
  document.querySelectorAll(".gallery img").forEach(img => {
    img.addEventListener("load", () => {
      img.style.opacity = "1";
    });
    if (img.complete) {
      img.style.opacity = "1";
    }
  });
});
</script>

</body>
</html>